#!/usr/bin/env python3
import time
from Vertex import Vertex

__author__ = 'Greg Dreifus'

in_file_path = './VertexPath.txt'
out_file_path = './RepRapTests.gcode'
layers = []

# Define Print Settings.
num_layers = 1
epew = 0.50 #external perimeters extrusion width
pew = 0.72 #perimeters extrusion width
iew = 0.72 #infill extrusion width
tiew = 0.72 #top infill extrusion width

FlayerZ = 7800.000 #Feedrate to next layer?
Flayer1 = 2400.00000 #Feedrate to purge?

E_purge = -2.00000 #purge extrusion?
distance = 0 #the distance traveled at each time step
E_ratio = 1.06 / 40 #the ratio of material extruded to distance traveled in mm?
E_val = distance * E_ratio #eparameter


layer_thickness = 2.54  # incremental increase in height per Layer
tableHeight = 0
# z_lift = 2
feed = 4000
start_height = 0  # a temp z_lift to be updated for absolute coordinates
# start_x = 1071.428571 for complex geometry
scale_down_factor = 2#100
start_x = 622.0441539999999 / scale_down_factor
start_y = 700 / scale_down_factor

# Read in vertex path file formatted as:
# xx.xxx yy.yyy zz.zzz print
# where print is 1 if printing when leaving node and 0 otherwise.
#with open(in_file_path) as f, open('check_file.txt', 'w') as check_file:
with open(in_file_path) as f:
    previous_z_value = -1.0
    is_airtime = True # Initial move to the first vertex is an airtime move.
    reading_interior = False # Initially reading boundary vertices.

    for line in f:
        if line[0] == '#': # Skip comment lines.
            continue
        
        line_elements = line.split()

        if len(line_elements[0]) > 5:
            reading_interior = True

        # Handle start of a new layer indicated by change in z-value.
        if float(line_elements[2]) != previous_z_value:
            new_layer = []
            layers.append(new_layer)
            reading_interior = False
            previous_z_value = float(line_elements[2])

        #                    xx.xxx           yy.yyy              AirTime
        tmp_vertex = Vertex(line_elements[0], line_elements[1], is_airtime)

        # Change units from the input decimeters to millimeters.
        tmp_vertex = Vertex(tmp_vertex.x * 100 / scale_down_factor, tmp_vertex.y * 100 / scale_down_factor, tmp_vertex.isAirtime)

        if not reading_interior: # Scale up boundary vertices by 1.4 to fit interior.
            tmp_vertex = Vertex(tmp_vertex.x * 1.4, tmp_vertex.y * 1.4, tmp_vertex.isAirtime)

        #if len(layers) == 5:
        #    check_file.write(str(tmp_vertex.x) + ' ' + str(tmp_vertex.y) + '\r\n')

        # Print parameter of this vertex determines the airtime parameter
        # of the next vertex.
        if line_elements[3] == '0':
            is_airtime = True
        else:
            is_airtime = False

        # Delete the previous vertex if it and the current vertex are both
        # airtime. This allows the printer head to travel directly to the next
        # extruded vertex, instead of backtracking along already extruded edges.
        if tmp_vertex.isAirtime and layers[-1] and layers[-1][-1].isAirtime:
            del layers[-1][-1]

        layers[-1].append(tmp_vertex)

with open(out_file_path, 'w') as outfile:
    # Write Initial GCode Commands to file.
    outfile.write('; generated by Slic3r 1.2.9\n\n')
    
    outfile.write('; external perimeters extrusion width = 0.50mm\n')
    outfile.write('; perimeters extrusion width = 0.72mm\n')
    outfile.write('; infill extrusion width = 0.72mm\n')
    outfile.write('; solid infill extrusion width = 0.72mm\n')
    outfile.write('; top infill extrusion width = 0.72mm\n\n')

    outfile.write('M107\n')
    outfile.write('M104 S200 ; set temperature\n')
    outfile.write('G28 ; home all axes\n')
    outfile.write('G1 Z5 F5000 ; lift nozzle\n\n')
    
    outfile.write('M109 S200 ; wait for temperature to be reached\n')
    outfile.write('G21 ; set units to millimeters\n')
    outfile.write('G90 ; use absolute coordinates\n')
    outfile.write('M82 ; use absolute distance for extrusion\n')
    outfile.write('G92 E0\n')

    outfile.write('; Start Build\n')
    outfile.write('; Layer count {0}\n\n'.format(len(layers)))

    for layer in range(1, len(layers) + 1):
        outfile.write('; Begin Layer {0}\n'.format(layer))

        if layer == 1:
            outfile.write('G1 Z{0} F{1}\n'.format(layer_thickness,FlayerZ))
            outfile.write('G1 E{0} F{1}\n'.format(E_purge,Flayer1))
            outfile.write('G92 E0\n')
    
        for (index, vertex) in enumerate(layers[layer - 1]):
            # Continue to second loop iteration if on the first
            # so we have Vertices[index] and Vertices[index - 1] defined.
            #if index == 0:
                #outfile.write('G1 X{0} Y{1} ; TRAVEL\n'.format(vertex.x - start_x, vertex.y - start_y))
                #continue
            

            airTime = layers[layer-1][index].isAirtime
            #if layer == 1:
                #airTime=1
            distance = ((vertex.x)**2+(vertex.y)**2)**(1/2)
            E_val = distance * E_ratio #eparameter

            #outfile.write(airTime)
            #if layer != 1:
                #if index + 1 >= len(layers[layer - 1]) or layers[layer - 1][index + 1].isAirtime:
                    #outfile.write('G1 Z{0} F{1}\n'.format(layer_thickness,FlayerZ))
                    #outfile.write('G1 X{0} Y{1} E{2} F{3}\n'.format(vertex.x, vertex.y,E_val,FlayerZ))
                    

            # Turn off extruder and raise if airtime.
            if airTime:
                outfile.write('G1 Z{0} F{1}\n'.format(layer_thickness,FlayerZ))
                outfile.write('G1 X{0} Y{1} E0\n'.format(vertex.x, vertex.y))
                outfile.write('G1 Z0\n')
            else:
                outfile.write('G1 X{0} Y{1} E{2}\n'.format(vertex.x,vertex.y,E_val))
                if index == 0:
                    outfile.write(' F{0}\n'.format(FlayerZ))
                else:
                    outfile.write('\n')
            

            # If we are on the last edge or the next edge is airtime.
            
        

        # Turn extruder off and raise to next layer height.
        outfile.write('G1 Z{0} F{1}\n'.format(layer_thickness,FlayerZ))

    outfile.write('G92 E0')
    outfile.write('M107')
    outfile.write('M104 S0')
    outfile.write('G28')
    outfile.write('M84')
